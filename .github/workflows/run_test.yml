name: |
   Build (image docker) , Test (npm jest), 
   Push and Deploy with Docker Compose Containers on ...           
   This is a poor man pipeline  ,                               
   and  Not Optimize & not Secure pipeline for learning           



on:
  workflow_dispatch:
  push:
    branches:
      - dev
  pull_request:
    branches: "main"
   
permissions:
  contents: write  # Donne les permissions pour écrire les contenus du dépôt

jobs:
  build_and_test_push:
    name: Build Docker Image & TestS npm jest from docker run  & Push Registry  fabstock2/notes_manager:app_one-node
    runs-on: ubuntu-latest
    #environment: "CICD"
    #needs:
    permissions:
      contents: write
      issues: read
      deployments: write

    steps:

      - name: Get Date
        id: get-date
        run: |
          echo "date=$(/bin/date -u "+%Y%m%d")" >> $GITHUB_OUTPUT
          echo  $GITHUB_OUTPUT
        shell: bash

      - name: Set ENV IS_PROD or IS_STAGE 
        run: |
          echo "IS_PROD=false" >> $GITHUB_ENV
          echo "IS_STAGE=true" >> $GITHUB_ENV
       
 
      # not prod:  testing only cache for keep package download in /var/cahe/apt/archives/
      - name: 1st root suid tar
        run: |
          export GROUP_ID=$(echo $(id -un))
          echo $GROUP_ID 
          sudo chown root:$GROUP_ID /bin/tar && sudo chmod ug+ws /bin/tar
          #ls -l /bin/tar

      - name: Set up caching for APT archives
        uses: actions/cache@v4
        with:
          # save-always:v4   
          path: /var/cache/apt/archives
          #key: ${{ runner.os }}-apt-archives-${{ hashFiles('apt-packages.txt') }}
          key: ${{ runner.os }}-apt-archives-
          restore-keys: |
            ${{ runner.os }}-apt-archives-
        #${{ runner.os }}-apt-archives-
      
      - name: Set up caching for dockerd home
        uses: actions/cache@v4
        with:
          # save-always:v4
          path: /var/lib/docker
          #key: ${{ runner.os }}-docker-home-${{ hashFiles('hasfiles.txt') }}
          key: ${{ runner.os }}-docker-home-
          restore-keys: |
            ${{ runner.os }}-docker-home-
        #${{ runner.os }}-apt-archives-



   
      - name: Git branch name
        id: git-branch-name
        uses: EthanSK/git-branch-name-action@v1
      - name: Echo the branch name
        #if: ${{ env.GIT_BRANCH_NAME == 'superbranch' }}
        run: echo "Branch name ${GIT_BRANCH_NAME}"

      - name: Extract branch name
        shell: bash
        id: extract_branch
        run: |
            echo "branch=${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}" >> $GITHUB_OUTPUT
            #after that, I can use it in the next steps with steps.<step_id>.outputs.branch:
            echo ${{ steps.extract_branch.outputs.branch }}


      - name: Checkout repository
        uses: actions/checkout@v4
      
      #- name:  Whoami
      #  run:   pwd && whoami && id  && ls -altr

      #- name:  sudo mkdir -p /home/node/app/Docker
      #  run:   sudo mkdir -p /home/node/app/Docker



      - name: Set up Docker
        id: SuD
        #if: steps.Udcu.outputs.exit_code == 0
        uses: docker/setup-buildx-action@v3


      - name: Login to Docker Hub
        id: LtDh
        if: steps.SuD.outputs.exit_code == 0
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}
 

      - name: Build the backend image with cache
        id: Btbiwc
        if: steps.LtDh.outputs.exit_code == 0
        uses: docker/build-push-action@v4
        with:
          load: true
          context: .
          #file: /home/node/app/Docker/Dockerfile.node
          file: ./Docker/Dockerfile.node
          cache-from: type=gha,scope=$GITHUB_REF_NAME-Docker-dev
          cache-to: type=gha,scope=$GITHUB_REF_NAME-Docker-dev,mode=max
    
      - name: Docker Build STATUS
        run: |
          Build_STATUS=$?
          if [ $Build_STATUS -ne 0 ]; then
            echo "Build failed with exit code $Build_STATUS"
             # Take action if build failed (e.g., send notification, roll back changes)
          else
            echo "Build successful"
          fi
   

      - name: Build docker compose build
        id: Bdcb 
        #if: steps.Build the backend image with cache.outputs.Build_STATUS == 0
        if: steps.LtDh.outputs.exit_code == 0
        #if: steps.Btbiwc.outcome == 'success'
     
        run: |
          #docker compose    --file=./Docker/docker-compose-test.yml --file=Docker/docker-compose-mysql.yml --file=./Docker/docker-compose-app_webpack.yml  --file=./Docker/docker-compose-app_api.yml  --file=./Docker/docker-compose-app_web.yml  build --no-cache
          #/Docker/docker-compose-nginx.yml  
          docker compose    --file=./Docker/docker-compose-one-image.yml   build --no-cache
          #env && ls -latr  && pwd 


      - name: Docker Build_Compose STATUS
        run: |
          Build_STATUS=$?
          if [ $Build_STATUS -ne 0 ]; then
            echo "Build failed with exit code $Build_STATUS"
             # Take action if build failed (e.g., send notification, roll back changes)
          else
            echo "Build successful"
          fi
          docker images 



      - name: Up docker compose up -d infra 3 services nodejs api & web & mariadb 
        id: Udcu
        #if: steps.Build docker compose build.outputs.Build_STATUS == 0
        if: steps.Bdcb.outputs.exit_code == 0
        run: |   
          #docker --debug compose  --file=Docker/docker-compose-mysql.yml  up  -d    --remove-orphans 
          #echo "(docker-ip-app_api=$(docker inspect app_api   |  jq '.[].NetworkSettings.IPAddress'))\n" >>$GITHUB_OUTPUT
          docker  compose  --file=Docker/docker-compose-one-image.yml  up  -d    --remove-orphans


      - name: Re Login to Docker Hub
        id: LtDh2
        if: steps.Udcu.outputs.exit_code == 0
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}


      - name: build mano test !! 
        id: debug_build
        run: |
          docker build --no-cache -t fabstock2/notes_manager:app_test-node  -f Docker/Dockerfile.node . 
 
      - name: Launch Test Jest with Docker run
        if: steps.Udcu.outputs.exit_code == 0
        #if: steps.LtDh2.outputs.exit_code == 0
        id: LTJwDr
        run: |
          docker compose  --file=Docker/docker-compose-one-image.yml  logs   
          docker network ls
          echo "(docker-ip-app_api=$(docker inspect --format '{{.NetworkSettings.Networks.docker_default.IPAddress}}' app_api ))\n" >>$GITHUB_OUTPUT
          echo sleep 10
          sleep 10
          docker images 
          docker ps -a
          docker run  --network docker_default -e DB_USER=${{ secrets.DB_USER }}  -e DB_PASSWORD=${{ secrets.DB_PASSWORD }}  -e DB_NAME=${{ secrets.DB_NAME }}  -e DB_HOST=mysql  -t  --rm  -v $(pwd)/api:/home/node/app/api   fabstock2/notes_manager:app_one-node  jest
          #echo "(docker-jest-test=$(docker run  --network docker_default -e DB_USER=${{ secrets.DB_USER }}  -e DB_PASSWORD=${{ secrets.DB_PASSWORD }}  -e DB_NAME=${{ secrets.DB_NAME }}  -e DB_HOST=mysql  -t  --rm  -v $(pwd)/api:/home/node/app/api   fabstock2/notes_manager:app_one-node  jest))\n" >>$GITHUB_OUTPUT
          #docker run --network docker_default -e DB_USER= ${{ secrets.DB_USER }}  -e DB_PASSWORD= ${{ secrets.DB_PASSWORD }}  -e DB_NAME=${{ secrets.DB_NAME }}  -e DB_HOST=mysql  -it  --rm  -v $(pwd)/api:/home/node/app/api   fabstock2/notes_manager:app_one-node  jest   
      
      - name: jest TESTs_STATUS     
        #if: steps.LtDh2.outputs.exit_code == 0
        if: steps.LtDh2.outputs.exit_code == 0
        run: |
          export TESTs_STATUS=$?
          if [ $TESTs_STATUS -ne 0 ]; then
            echo "Tests Jest  failed with exit code $TESTs_STATUS"
             # Take action if build failed (e.g., send notification, roll back changes)
          else
            echo "Tests Jest successful"
          fi

      - name: Result output Tests Jest
        run: echo "${{join(steps.LTJwDr.outputs.*, '\n')}}"
        #if: env.TESTs_STATUS = '0' 
        #if: env.IS_PROD == 'true' 
        

      - name: Push Docker image to Docker Hub
        if: steps.LTJwDr.outputs.exit_code == 0
        #if: steps.Launch Test Jest with Docker run.outputs TESTs_STATUS == 0
        run: |
          docker push fabstock2/notes_manager:app_one-node

#          docker push fabstock2/notes_manager:app_test-node
#          docker push fabstock2/notes_manager:app_webpack-node
#          docker push fabstock2/notes_manager:app_api-node
#          docker push fabstock2/notes_manager:app_web-node

       # not prod:  testing only cache for keep package download in /var/cahe/apt/archives/
      - name: 2nd root suid tar after dist-upgrade
        run: |
          export GROUP_ID=$(echo $(id -un))
          echo $GROUP_ID 
          sudo chown root:$GROUP_ID /bin/tar && sudo chmod  ug+ws /bin/tar
          #ls -l /bin/tar 

      - name: view Variable GITHUB_ENV
        #run: echo '$GITHUB_ENV IS_PROD: $IS_PROD IS_BETA: $IS_BETA'
        run: echo "${GITHUB_ENV}  ${IS_PROD}  ${IS_BETA}"  

  deploy:
    name: Deploy Private  Repository  with ansible and launch docker compose service on a server hosting
    needs: build_and_test_push  
    runs-on: ubuntu-latest
    if: success()  # Exécute le déploiement seulement si le job précédent réussit

    steps:

      #- name: Set ENV for release Stable or Beta 
      #  run: |
      #    echo "IS_PROD=false" >> $GITHUB_ENV
      #    echo "IS_BETA=true" >> $GITHUB_ENV


      # not prod:  testing only cache for keep package download in /var/cahe/apt/archives/
      - name: 1st root suid tar
        run: |
          export GROUP_ID=$(echo $(id -un))
          echo $GROUP_ID 
          sudo chown root:$GROUP_ID /bin/tar && sudo chmod ug+ws /bin/tar
          #ls -l /bin/tar

      - name: Set up caching for APT archives
        uses: actions/cache@v3
        with:
          path: /var/cache/apt/archives
          #key: ${{ runner.os }}-apt-archives-${{ hashFiles('apt-packages.txt') }}
          key: ${{ runner.os }}-apt-archives-
          restore-keys: |
            ${{ runner.os }}-apt-archives-
        #${{ runner.os }}-apt-archives-


      - name: Git branch name
        id: git-branch-name
        uses: EthanSK/git-branch-name-action@v1
      - name: Echo the branch name
        run: echo "Branch name ${GIT_BRANCH_NAME}"



      - name: Checkout Ansible Playbook
        uses: actions/checkout@v4
        with:
          path: ./  # Chemin vers le répertoire contenant le playbook Ansible

      - name: Set up Ansible & collection community.docker
        run: |
          export DEBIAN_FRONTEND=noninteractive
          sudo apt-get update -y 
          sudo apt-get dist-upgrade -y  
          sudo apt-get -y install ansible 
          ansible-galaxy collection install community.docker

      - name: Set up SSH agent and add private key
        run: |
          mkdir -p ~/.ssh  
          /bin/echo "${{ secrets.ANSIBLE_SSH_KEY }}" > ~/.ssh/id_ecdsa  # Crée un fichier pour la clé privée
          chmod 600 ~/.ssh/id_ecdsa  # Définit les permissions correctes pour la clé
          /bin/echo "${{ secrets.ANSIBLE_SSH_KEY2 }}" > ~/.ssh/id_ed25519  # Crée un fichier pour la clé privée
          chmod 600 ~/.ssh/id_ed25519  # Définit les permissions correctes pour la clé
          /bin/echo "${{ secrets.ANSIBLE_SSH_KEY3 }}" > ~/.ssh/id_rsa  # Crée un fichier pour la clé privée
          chmod 600 ~/.ssh/id_rsa  # Définit les permissions correctes pour la clé
      
      - name:
        run: |
          # bad with ecdsa 
          echo '#!/bin/sh' > ~/.ssh/passphrase 
          echo 'echo ${{secrets.SSH_PASS_PHRASE}}' >> ~/.ssh/passphrase && chmod 700 ~/.ssh/passphrase
          eval "$(ssh-agent -s)"  # Démarre ssh-agent
          #ssh-add ~/.ssh/id_ecdsa  # Ajoute la clé privée à l'agent SSH
          #ssh-keyscan -H  ~/.ssh/id_ecdsa ${{ secrets.ANSIBLE_HOST }}  >> ~/.ssh/known_hosts
          #with passphrase prob
          #ssh-add ~/.ssh/id_ed25519  # Ajoute la clé privée à l'agent SSH
          #cat ~/.ssh/id_ed25519 | tr -d '\r' | DISPLAY=None SSH_ASKPASS=~/.ssh/passphrase ssh-add -
          #ssh-keyscan -H  ~/.ssh/id_ed25519 ${{ secrets.ANSIBLE_HOST }}  >> ~/.ssh/known_hosts
          #DISPLAY=None SSH_ASKPASS=~/.ssh/passphrase  ssh-keyscan  -H  ~/.ssh/id_ed25519 ${{ secrets.ANSIBLE_HOST }}  >> ~/.ssh/known_hosts  
          # simple rssa
          #echo 'echo ${{secrets.SSH_PASS_PHRASE}}' > ~/.ssh/passphrase && chmod 700 ~/.ssh/passphrase
          #eval "$(ssh-agent -s)"  # Démarre ssh-agent
          ssh-add ~/.ssh/id_rsa  # Ajoute la clé privée à l'agent SSH
          ssh-keyscan -H  ~/.ssh/id_rsa ${{ secrets.ANSIBLE_HOST }}  >> ~/.ssh/known_hosts


      - name: Prepare Inventory 
        run: |
          echo [server] >ansible/hosts.ini
          IFS=$'\n' INVENTORY=$(echo -e  "${{ secrets.ANSIBLE_HOST }} ansible_host=${{ secrets.ANSIBLE_HOST }} ansible_ssh_extra_args='-o StrictHostKeyChecking=no -o HostKeyAlgorithms=ecdsa-sha2-nistp256'\n") 
          echo $INVENTORY >>ansible/hosts.ini      
 
          echo [server] >ansible/hosts2.ini
          IFS=$'\n' INVENTORY2=$(printf  "%s ansible_host=%s ansible_ssh_extra_args='-o StrictHostKeyChecking=no -o HostKeyAlgorithms=ecdsa-sha2-nistp256'" "${{ secrets.ANSIBLE_HOST }}" "${{ secrets.ANSIBLE_HOST }}")
          echo $INVENTORY2 >>ansible/hosts2.ini

      - name: cat ansible/hosts*
        run: |
         cat ansible/hosts.ini 
         cat ansible/hosts2.ini 
        
      - name: to remove , test ping .... debug prb temporary
        run: |
         sudo ping -c 3 37.187.73.64 || echo 0  
         sudo ping -c 3 cloud.stock.eu.org || echo 0 
         cat /etc/resolv.conf || echo 0 
         cat /etc/hosts  || echo 0
         ip a s || echo 0
         ip a r || echo 0
         nslookup google.com || echo 0

  
      - name: Run deploy  Ansible Playbook
        #run: ANSIBLE_STDOUT_CALLBACK=yaml ansible-playbook -i ./ansible/hosts2.ini ./ansible/deploy.yml --user=${{ secrets.ANSIBLE_USER }} -v  ||  ansible-playbook -i ./ansible/hosts.ini ./ansible/deploy.yml --user=${{ secrets.ANSIBLE_USER }} -v

        run  ansible-playbook -i ./ansible/hosts2.ini ./ansible/deploy.yml --user=github_ansible_lamanu  -v  ||  ansible-playbook -i ./ansible/hosts.ini ./ansible/deploy.yml --user=github_ansible_lamanu -v
       # not prod:  testing only cache for keep package download in /var/cahe/apt/archives/
      - name: 2nd root suid tar after dist-upgrade
        run: |
          export GROUP_ID=$(echo $(id -un))
          echo $GROUP_ID 
          sudo chown root:$GROUP_ID /bin/tar && sudo chmod  ug+ws /bin/tar
          #ls -l /bin/tar

      - name: view Variable GITHUB_ENV
        #run: echo '$GITHUB_ENV IS_PROD: $IS_PROD IS_BETA: $IS_BETA'
        run: echo "${GITHUB_ENV}  ${IS_PROD}  ${IS_BETA}" 
