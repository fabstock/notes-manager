name: Build, Test, Push, and Deploy Docker Container

on:
  workflow_dispatch:
  push:
    branches:
      - dev  # Ajustez en fonction de votre branche de déploiement
  pull_request:
    branches: "main"
   
permissions:
  contents: write  # Donne les permissions pour écrire les contenus du dépôt

    

jobs:
  build_and_test:
    name: npm test jest 
    runs-on: ubuntu-latest
    #environment: "CICD"
    #needs:
    permissions:
      contents: write
      issues: read
      deployments: write

    steps:


      # not prod:  testing only cache for keep package download in /var/cahe/apt/archives/
      - name: 1st root suid tar
        run: |
          export GROUP_ID=$(echo $(id -un))
          echo $GROUP_ID
          sudo chown root:$GROUP_ID /bin/tar && sudo chmod ug+ws /bin/tar
          ls -l /bin/tar

      - name: Set up caching for APT archives
        uses: actions/cache@v3
        with:
          path: /var/cache/apt/archives
          #key: ${{ runner.os }}-apt-archives-${{ hashFiles('apt-packages.txt') }}
          key: ${{ runner.os }}-apt-archives-
          restore-keys: |
            ${{ runner.os }}-apt-archives-
        #${{ runner.os }}-apt-archives-


      - name: Git branch name
        id: git-branch-name
        uses: EthanSK/git-branch-name-action@v1
      - name: Echo the branch name
        run: echo "Branch name ${GIT_BRANCH_NAME}"

      - name: Checkout repository
        uses: actions/checkout@v4
 
      - name:  whoami
        run:   pwd && whoami && id  && ls -altr

      - name:  sudo mkdir -p /home/node/app/Docker 
        run:   sudo mkdir -p /home/node/app/Docker


      - name: Set up Docker
        uses: docker/setup-buildx-action@v2

      - name: Build the backend image with cache
        uses: docker/build-push-action@v4
        with:
          load: true
          context: .
          #file: /home/node/app/Docker/Dockerfile.node
          file: ./Docker/Dockerfile.node
          cache-from: type=gha,scope=$GITHUB_REF_NAME-Docker-dev
          cache-to: type=gha,scope=$GITHUB_REF_NAME-Docker-dev,mode=max


      - name: build docker compose 
        run: |
          #docker compose    --file=./Docker/docker-compose-test.yml --file=Docker/docker-compose-mysql.yml --file=./Docker/docker-compose-app_webpack.yml  --file=./Docker/docker-compose-app_api.yml  --file=./Docker/docker-compose-app_web.yml  build --no-cache
          docker compose    --file=./Docker/docker-compose-one-image.yml   build --no-cache
          #/Docker/docker-compose-nginx.yml  
          docker images 
          #env && ls -latr  && pwd 


      - name: test jest with docker compose 
        run: |   
          docker  compose  --file=Docker/docker-compose-one-image.yml  up  -d    --remove-orphans
          docker ps -a
          #docker --debug compose  --file=Docker/docker-compose-mysql.yml  up  -d    --remove-orphans 
          #sudo apt-get update
          #sudo apt-install  -y install
          #env && ls -latr  && pwd 
        
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}

      - name: Push Docker image to Docker Hub
         run: |
           docker push fabstock2/notes_manager:app_one-node

#          docker push fabstock2/notes_manager:app_test-node
#          docker push fabstock2/notes_manager:app_webpack-node
#          docker push fabstock2/notes_manager:app_api-node
#          docker push fabstock2/notes_manager:app_web-node




       # not prod:  testing only cache for keep package download in /var/cahe/apt/archives/
      - name: 2nd root suid tar after dist-upgrade
        run: |
          export GROUP_ID=$(echo $(id -un))
          echo $GROUP_ID
          sudo chown root:$GROUP_ID /bin/tar && sudo chmod  ug+ws /bin/tar
          ls -l /bin/tar

      - name: Set ENV for release Stable or Beta 
        run: |
          echo "IS_PROD=false" >> $GITHUB_ENV
          echo "IS_BETA=true" >> $GITHUB_ENV

      - name: view Variable GITHUB_ENV
        #run: echo '$GITHUB_ENV IS_PROD: $IS_PROD IS_BETA: $IS_BETA'
        run: echo "${GITHUB_ENV}  ${IS_PROD}  ${IS_BETA}"


  deploy:
    needs: build_and_test
    runs-on: ubuntu-latest
    if: success()  # Exécute le déploiement seulement si le job précédent réussit

    steps:
      - name: Checkout Ansible Playbook
        uses: actions/checkout@v4
        with:
          path: ./  # Chemin vers le répertoire contenant le playbook Ansible



      - name: Set up Ansible & collection community.docker
        run: |
          export DEBIAN_FRONTEND=noninteractive
          sudo apt-get update -y 
          sudo apt-get dist-upgrade -y  
          sudo apt-get -y install ansible 
          ansible-galaxy collection install community.docker


      - name: Set up SSH agent and add private key
        run: |
          mkdir -p ~/.ssh  
          /bin/echo "${{ secrets.ANSIBLE_SSH_KEY }}" > ~/.ssh/id_ecdsa  # Crée un fichier pour la clé privée
          chmod 600 ~/.ssh/id_ecdsa  # Définit les permissions correctes pour la clé
          eval "$(ssh-agent -s)"  # Démarre ssh-agent
          ssh-add ~/.ssh/id_ecdsa  # Ajoute la clé privée à l'agent SSH
          ssh-keyscan -H  ~/.ssh/id_ecdsa ${{ secrets.ANSIBLE_HOST }}  >> ~/.ssh/known_hosts

      - name: Prepare Inventory 
        run: |
          echo [server] >ansible/hosts.ini
          IFS=$'\n' INVENTORY=$(echo -e  "${{ secrets.ANSIBLE_HOST }} ansible_host=${{ secrets.ANSIBLE_HOST }} ansible_ssh_extra_args='-o StrictHostKeyChecking=no -o HostKeyAlgorithms=ecdsa-sha2-nistp256'\n") 
          echo $INVENTORY >>ansible/hosts.ini
        
          echo [server] >ansible/hosts2.ini
          IFS=$'\n' INVENTORY2=$(printf  "%s ansible_host=%s ansible_ssh_extra_args='-o StrictHostKeyChecking=no -o HostKeyAlgorithms=ecdsa-sha2-nistp256'" "${{ secrets.ANSIBLE_HOST }}" "${{ secrets.ANSIBLE_HOST }}")
          echo $INVENTORY2 >>ansible/hosts2.ini



      - name: cat ansible/hosts*
        run: |
         cat ansible/hosts.ini
         cat ansible/hosts2.ini
        
  
      - name: Run Ansible Playbook deploy
        run: ANSIBLE_STDOUT_CALLBACK=yaml ansible-playbook -i ./ansible/hosts2.ini ./ansible/deploy.yml --user=${{ secrets.ANSIBLE_USER }} -v  ||  ansible-playbook -i ./ansible/hosts.ini ./ansible/deploy.yml --user=${{ secrets.ANSIBLE_USER }}
